#!/usr/bin/env bash
set -euo pipefail

# search - Content search with title extraction
# Usage: search <pattern> [search_path]
# Output: path | title
# By default excludes archive/, unless search_path explicitly includes it

# Validate $notes environment variable
if [ -z "${notes:-}" ]; then
  echo "Error: \$notes environment variable not set" >&2
  echo "Ensure direnv is installed and .envrc.local is configured" >&2
  exit 1
fi

if [ ! -d "$notes" ]; then
  echo "Error: \$notes does not point to a directory: $notes" >&2
  exit 1
fi

if [ ! -r "$notes" ]; then
  echo "Error: \$notes directory is not readable: $notes" >&2
  exit 1
fi

if [ $# -eq 0 ]; then
  echo "Usage: search <pattern> [search_path]" >&2
  echo "Example: search '(context|ctx).?(object|obj)'" >&2
  echo "Example: search 'pattern' 'archive/'  # Search archive" >&2
  exit 1
fi

pattern="$1"
# If search_path provided, resolve it relative to $notes, otherwise use $notes
if [ $# -ge 2 ]; then
  search_path="$notes/$2"
else
  search_path="$notes"
fi

# Exclude archive by default unless explicitly searching in archive
if [[ "$search_path" != *"archive"* ]]; then
  rg_cmd=(rg --files-with-matches --ignore-case --type md --glob '!archive/**' "$pattern" "$search_path")
else
  rg_cmd=(rg --files-with-matches --ignore-case --type md "$pattern" "$search_path")
fi

# Use ripgrep to find files matching pattern (case-insensitive, list files only)
"${rg_cmd[@]}" 2>/dev/null | while IFS= read -r file; do
  # Extract H1 title from first line
  title=$(head -1 "$file" 2>/dev/null | sed 's/^# //' || echo "")

  # If no title found, use filename
  if [ -z "$title" ]; then
    title=$(basename "$file" .md)
  fi

  # Output: path | title
  echo "$file | $title"
done
