---
title: Batch Process with Map Steps
description: Learn how to efficiently process arrays and collections in parallel using pgflow's map steps
sidebar:
  order: 35
---

import { Aside } from "@astrojs/starlight/components";

Map steps automatically spawn one task per array element, enabling parallel processing of variable-length collections. The key insight: **the array length determines task count at runtime** - whether processing 5 items or 5,000, the flow structure remains the same.

## Root Maps: Process Flow Input Arrays

When the flow input is an array, use a root map (no `array` property) to process each element:

```typescript
// Processes N URLs in parallel, where N is determined at runtime
const ScrapeUrls = new Flow<string[]>({ slug: 'scrape_urls' })
  .map({ slug: 'pages' }, (url) => scrapeWebpage(url))
  .step({ slug: 'summary', dependsOn: ['pages'] }, (input) =>
    summarizeResults(input.pages)
  );

// Start with 3 URLs -> spawns 3 tasks
// Start with 100 URLs -> spawns 100 tasks
```

## Dependent Maps: Process Step Output Arrays

When a step returns an array, downstream maps process those elements:

```typescript
// Variable-length pipeline: runtime determines how many items to process
const DataPipeline = new Flow<{ source: string }>({ slug: 'data_pipeline' })
  .step({ slug: 'rows' }, (input) => fetchCSV(input.run.source))  // Returns N rows
  .map({ slug: 'validated', array: 'rows' }, (row) => validateRow(row))  // N tasks
  .map({ slug: 'enriched', array: 'validated' }, (row) => enrichRow(row))  // N tasks
  .step({ slug: 'results', dependsOn: ['enriched'] }, (input) =>
    saveToDatabase(input.enriched)
  );
```

## Chained Maps: Multi-Stage Processing

Chain maps to transform data through multiple stages, each operating on the full array in parallel:

```typescript
// Each map stage processes all items in parallel
const ImagePipeline = new Flow({ slug: 'image_pipeline' })
  .step({ slug: 'urls' }, () => getImageUrls())
  .map({ slug: 'downloaded', array: 'urls' }, (url) => downloadImage(url))
  .map({ slug: 'resized', array: 'downloaded' }, (img) => resizeImage(img))
  .map({ slug: 'uploaded', array: 'resized' }, (img) => uploadToS3(img));
```

## Fan-Out Pattern: Runtime Array Expansion

Create arrays dynamically based on input, then process elements in parallel:

```typescript
// Single input expands into variable number of parallel operations
const NotifyUsers = new Flow<{ segmentId: string }>({ slug: 'notify_users' })
  .step({ slug: 'users' }, (input) =>
    getUsersInSegment(input.run.segmentId)  // Could return 10, 100, or 1000 users
  )
  .map({ slug: 'sent', array: 'users' }, (user) => sendEmail(user))
  .step({ slug: 'report', dependsOn: ['sent'] }, (input) =>
    generateReport(input.sent)
  );
```

<Aside type="tip">
The array length is unknown until runtime. The same flow definition handles both small batches (5 items) and large ones (5,000 items) without modification.
</Aside>

## Including Flow Context in Map Tasks

Map handlers only receive individual elements. To access flow input, enrich array elements first:

```typescript
// Problem: Map can't access input.run
const Problem = new Flow<{ apiKey: string, ids: string[] }>({ slug: 'problem' })
  .map({ slug: 'data' }, (id) => fetchData(id, ???));  // No access to apiKey

// Solution: Bundle context into array elements
const Solution = new Flow<{ apiKey: string, ids: string[] }>({ slug: 'solution' })
  .array({ slug: 'items' }, (input) =>
    input.run.ids.map(id => ({ id, apiKey: input.run.apiKey }))
  )
  .map({ slug: 'data', array: 'items' }, (item) =>
    fetchData(item.id, item.apiKey)
  );
```

## Empty Arrays Cascade Automatically

Empty arrays complete immediately and propagate through dependent maps:

```typescript
const HandleEmpty = new Flow({ slug: 'handle_empty' })
  .step({ slug: 'items' }, () => fetchItems())  // Might return []
  .map({ slug: 'processed', array: 'items' }, (item) => processItem(item))  // Skips if empty
  .step({ slug: 'result', dependsOn: ['processed'] }, (input) =>
    input.processed.length === 0
      ? { message: 'No items' }
      : { count: input.processed.length }
  );
```

## Summary

Map steps provide variable-length parallel processing:

- **Root maps**: Process flow input arrays (array length unknown until flow starts)
- **Dependent maps**: Process step output arrays (array length determined by upstream step)
- **Chained maps**: Multi-stage transformations across full arrays
- **Context bundling**: Enrich elements with flow input when needed
- **Empty handling**: Zero-length arrays complete instantly and cascade

The same flow structure adapts to any array size at runtime - from single items to thousands.

For detailed internals, see [Array and Map Steps](/concepts/array-and-map-steps/).