---
title: Batch Process with Map Steps
description: Learn how to efficiently process arrays and collections in parallel using pgflow's map steps
sidebar:
  order: 35
---

import { Aside, Steps } from "@astrojs/starlight/components";

This guide shows practical patterns for using map steps to process collections of data in parallel, from simple transformations to complex batch operations.

## Understanding Map Step Flavors

Map steps process arrays in two ways:

- **Root maps** - Process the flow input array directly (omit `array` property)
- **Dependent maps** - Process another step's array output (specify `array` property)

The examples below show both patterns. For conceptual details, see [Map Steps](/concepts/map-steps/).

## Processing a List of URLs

A common use case is fetching and processing multiple web pages in parallel.

### Basic URL Processing

```typescript
import { Flow } from '@pgflow/dsl/supabase';

const ScrapeMultipleUrls = new Flow<string[]>({  // Flow input must be array for root map
  slug: 'scrape_multiple_urls',
  maxAttempts: 3,
})
  .map(
    { slug: 'scrapedPages' },
    async (url) => await scrapeWebpage(url)
  )
  .step(
    { slug: 'summary', dependsOn: ['scrapedPages'] },
    (input) => summarizeResults(input.scrapedPages)
  );

// Usage (SQL):
SELECT pgflow.start_flow(
  flow_slug => 'scrape_multiple_urls',
  input => '["https://example.com", "https://example.org", "https://example.net"]'::jsonb
);
```


## Batch API Calls

Make multiple API calls in parallel while respecting rate limits.

### Simple Batch API Calls

```typescript
const BatchApiCalls = new Flow<string[]>({  // Array input for root map
  slug: 'batch_api_calls',
})
  .map(
    { slug: 'users' },
    async (userId) => await fetchUserData(userId)
  )
  .step(
    { slug: 'summary', dependsOn: ['users'] },
    (input) => generateUserReport(input.users)
  );
```


## Data Transformation Pipeline

Transform and validate data collections efficiently.

### CSV Processing Pipeline

```typescript
const CsvProcessor = new Flow<{ csvUrl: string }>({
  slug: 'csv_processor',
})
  .array(
    { slug: 'csvRows' },
    async (input) => await fetchAndParseCSV(input.run.csvUrl)
  )
  .map(
    { slug: 'validatedRows', array: 'csvRows' },
    (row) => validateRow(row)
  )
  .map(
    { slug: 'processedRows', array: 'validatedRows' },
    (row) => transformIfValid(row)
  )
  .step(
    { slug: 'saveResults', dependsOn: ['processedRows'] },
    async (input, context) => await saveProcessedData(input.processedRows, context)
  );
```

## Enriching Array Elements with Additional Data

Map handlers only receive individual array elements. If a handler needs access to flow input, other step outputs, or any additional data, include that data in the array elements via a previous step.

### Problem: Needing Data Beyond Array Elements

```typescript "apiKey: string" del="id, ???" del="(id)"
// This won't work - map handler can't access input.run
const ProblemFlow = new Flow<{ apiKey: string, ids: string[] }>({
  slug: 'problem_flow',
})
  .map({ slug: 'fetch' }, async (id) => {
    // Can't access input.run.apiKey here!
    return await fetchWithKey(id, ???);  // No access to apiKey
  });
```

### Solution: Enrich Array Elements

```typescript ins={4-13} ins="item.id, item.apiKey" ins="(item)"
const SolutionFlow = new Flow<{ apiKey: string, ids: string[] }>({
  slug: 'solution_flow',
})
  .array(
    { slug: 'prepareItems' },
    (input) => {
      // Include needed context in each element
      return input.run.ids.map(id => ({
        id,
        apiKey: input.run.apiKey
      }));
    }
  )
  .map(
    { slug: 'fetch', array: 'prepareItems' },
    async (item) => {
      // Now we have access to both id and apiKey
      return await fetchWithKey(item.id, item.apiKey);
    }
  );
```

This pattern applies whenever a map handler needs any data beyond the array elements themselves. Add a step before the map that enriches the array elements with whatever data the handler needs.

## Debugging Map Steps

When debugging map steps, you need to understand how individual tasks behave.

### Logging Individual Task Progress

```typescript
const DebugFlow = new Flow<{ items: string[] }>({
  slug: 'debug_flow',
})
  .map(
    { slug: 'processWithLogging' },
    async (item, context) => {
      const taskIndex = context.stepTask.task_index;

      console.log(`Task ${taskIndex}: Starting to process "${item}"`);

      try {
        const result = await processItem(item);
        console.log(`Task ${taskIndex}: Successfully processed "${item}"`);
        return { success: true, item, result };
      } catch (error) {
        console.error(`Task ${taskIndex}: Failed to process "${item}":`, error);
        return { success: false, item, error: error.message };
      }
    }
  );
```

## Common Gotchas and Solutions

### Handling Empty Arrays

Empty arrays cascade through map steps automatically:

```typescript
const EmptyHandling = new Flow<{}>({
  slug: 'empty_handling',
})
  .array({ slug: 'items' }, async () => {
    const results = await fetchData();
    return results || [];  // Might return []
  })
  .map(
    { slug: 'processedItems', array: 'items' },
    (item) => processItem(item)
  )
  .step(
    { slug: 'handleResults', dependsOn: ['processedItems'] },
    (input) => {
      if (input.processedItems.length === 0) {
        return { message: 'No items to process' };
      }
      return { processed: input.processedItems.length };
    }
  );
```

## Summary

Map steps provide powerful parallel processing capabilities for pgflow workflows:

- **URL Processing**: Fetch and process multiple web pages concurrently
- **API Batching**: Make parallel API calls with rate limiting
- **Data Pipelines**: Transform and validate collections efficiently
- **Result Aggregation**: Process individually, analyze collectively

Remember to:
- Include necessary context in array elements
- Handle errors gracefully at the individual task level
- Consider rate limits and resource constraints
- Use chunking for very large arrays
- Monitor task execution for debugging

For more details on how map steps work internally, see the [Map Steps](/concepts/map-steps/) concepts guide.
