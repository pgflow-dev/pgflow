---
title: Version your flows
description: Learn how to safely update your flows without breaking existing runs
sidebar:
  order: 50
---

import { CardGrid, LinkCard, Steps, FileTree } from '@astrojs/starlight/components';

## Current Compilation Limitations

**Important:** The current version of pgflow's compiler has several limitations:

1. Always creates a **new migration file** for any changes
2. Does not provide automatic update functionality for existing flows
3. Cannot safely change step dependencies or flow structure

For any changes to an existing flow, you must:
- Manually handle migration files
- For non-breaking changes, manually update using SQL commands

:::danger[Prohibited Changes]
DO NOT attempt to change these aspects of an existing flow:
- Step slugs
- Dependencies between steps
- Adding or removing steps
- Altering the flow's input type structure

These changes will break in-progress runs and cause data compatibility issues.
:::

## Understanding Safe vs. Breaking Changes

Before making changes to your flows, understand which modifications are safe:

| Safe Changes | Breaking Changes |
| ------------ | --------------- |
| ✅ Modifying step implementation | ❌ Adding/removing steps |
| ✅ Adjusting retry parameters | ❌ Changing step dependencies |
| ✅ Updating timeout values | ❌ Modifying input/output types |
| ✅ Bug fixes within steps | ❌ Changing step slug names |

## Version Management Strategy

To create a new version of an existing flow, we'll create a new flow definition in a separate file with a versioned slug. The new version can reuse tasks from the previous version while implementing different logic or structure. Your project structure will look like this:

<FileTree>
- supabase/functions/
  - _tasks/
    - fetchUserData.ts
    - sendEmail.ts
  - _flows/
    - greet_user.ts        // Original version
    - greet_user_v2.ts     // New version
</FileTree>

<Steps>

1. **Create new flow definition file**

   Create a new flow file with a versioned slug that can reuse existing tasks:

   ```typescript
   // supabase/functions/_flows/greet_user_v2.ts
   export default new Flow<Input>({
     slug: 'greet_user_v2',  // Note the versioned slug
     // ...new configuration and step definitions
   })
   ```

2. **Compile new migration**

   [Compile the new flow to SQL](/getting-started/compile-to-sql/) which generates a migration file for the new version:

   ```bash frame="none"
   npx pgflow@latest compile supabase/functions/_flows/greet_user_v2.ts
   ```

3. **Apply migration to database**

   Apply the migration to register the new flow version alongside the existing one:

   ```bash frame="none"
   npx supabase migrations up --local
   ```

</Steps>

The new flow version is registered as a completely separate entity in the database, leaving the previous version untouched and available for existing runs.

## Updating Non-Breaking Configuration Options

For non-breaking changes like adjusting retry settings or timeouts, you must manually update the database with SQL commands.

We've created a detailed guide on [how to update flow options](/how-to/update-flow-options/) that covers:
- All available configuration options
- SQL commands for updating flows and steps
- Best practices for maintaining compatibility

For any non-breaking changes to existing flows, refer to this guide rather than recompiling.

## Development Workarounds

During development, if you need to make breaking changes to a flow, you can [delete the flow and its data](/how-to/delete-flow-and-data/) entirely and start fresh. This approach deletes all flow data and should never be used in production.

## See Also

<CardGrid>
  <LinkCard
    title="Delete flow and its data"
    description="Remove a flow completely during development"
    href="/how-to/delete-flow-and-data/"
  />
  <LinkCard
    title="Update flow options"
    description="Non-breaking configuration changes"
    href="/how-to/update-flow-options/"
  />
</CardGrid>
