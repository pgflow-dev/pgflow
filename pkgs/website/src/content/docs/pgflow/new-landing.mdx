---
title: pgflow
description: Postgres-First Workflow Orchestration—All in SQL
template: splash
hero:
  title: Build AI Agent Workflows on Supabase
  tagline: pgflow adds deterministic, parallel orchestration on top of Supabase Background Jobs - no extra servers needed
  image:
    dark: ../../../assets/pgflow-logo-dark.svg
    light: ../../../assets/pgflow-logo-light.svg
  actions:
    - text: Get Started
      link: /pgflow/getting-started/install-pgflow/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/pgflow-dev/pgflow
      icon: github
      variant: minimal
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## A complete workflow engine built on Postgres

pgflow is a workflow orchestration system with its core state management in your database, combining:

<CardGrid>
  <Card title="SQL Core" icon="database">
    Pure SQL implementation that handles workflow definitions, state transitions, and ACID-compliant processing directly in your Postgres database.
  </Card>
  <Card title="TypeScript DSL" icon="pencil">
    Type-safe API for defining workflows that automatically infers input/output types between steps, providing compile-time safety.
  </Card>
  <Card title="Edge Worker" icon="setting">
    Self-restarting worker that processes tasks with built-in retries and error handling, designed for Supabase Edge Functions.
  </Card>
  <Card title="CLI Tools" icon="terminal">
    One-command setup with `npx pgflow install` that handles migrations, configuration, and deployment.
  </Card>
</CardGrid>

## Type-safe DAG workflows in TypeScript

Define complex workflows with parallel execution and dependencies using a simple, type-safe API:

```typescript
// Define a workflow with parallel steps
new Flow<{ url: string }>()
  .step("website", async ({ url }) => {
    const response = await fetch(url);
    return { content: await response.text() };
  })
  .step("sentiment", ["website"], async ({ website }) => {
    return await analyzeSentiment(website.content);
  })
  .step("summary", ["website"], async ({ website }) => {
    return await summarizeWithAI(website.content);
  })
  .step("saveToDb", ["sentiment", "summary"], async (input) => {
    return await saveResults({
      url: input.run.url,
      sentiment: input.sentiment.score,
      summary: input.summary
    });
  });
```

## End-to-end workflow orchestration

<CardGrid>
  <Card title="Single source of truth" icon="open-book">
    All workflow definitions, state, and execution history stored in your Postgres database—simplifying monitoring and debugging.
  </Card>

  <Card title="Reliable task processing" icon="rocket">
    Built on [PGMQ](https://github.com/tembo-io/pgmq) for at-least-once delivery with automatic retries, timeouts, and dead-letter handling.
  </Card>

  <Card title="Supabase-native" icon="puzzle">
    Deploy as Edge Functions with automatic restarts and zero-config integration with your existing Supabase project.
  </Card>

  <Card title="Developer experience" icon="approve-check">
    Full type inference between workflow steps with IDE autocompletion and compile-time safety for your entire workflow DAG.
  </Card>
</CardGrid>

## From workflow DSL to execution

Create and run workflows with a straightforward process:

1. **Define your workflow** in TypeScript with the Flow DSL, specifying handlers and dependencies
2. **Generate SQL migrations** from your workflow definition
3. **Create a dedicated worker** as a Supabase Edge Function for your flow
4. **Start workflows** from your application code, SQL triggers, or APIs

The execution system handles the rest—scheduling steps when dependencies complete, retrying failed tasks, and aggregating results automatically.

## Ready to get started?

Install pgflow in your Supabase project with a single command:

```bash
npx pgflow install
```
