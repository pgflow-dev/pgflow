---
draft: false
title: 'Context - Simplify Your Handler Functions'
description: 'pgflow workers now provide a context object for accessing platform resources like database connections and Supabase clients.'
date: 2025-07-17
authors:
  - jumski
tags:
  - release
  - edge-worker
  - dsl
  - context
  - supabase
featured: true
cover:
  alt: 'Context object simplifying handler functions with platform resources'
  image: '../../../assets/cover-images/context-simplify-your-handler-functions.png'
---

import { Aside, Steps } from "@astrojs/starlight/components";

Workers now pass a **context object** as a second parameter to all handlers, providing ready-to-use database connections, environment variables, and Supabase clients.

## The Problem We Solved

Previously, handlers relied on global singletons or manual resource initialization:

```typescript del="import { sql }" del="import { supabase }" ins="ctx: Context" ins="ctx.sql" ins="ctx.serviceSupabase"
// Before: Global resources that complicated testing and lifecycle management
import { sql } from '../db.js';
import { supabase } from '../supabase-client.js';

// After: Clean dependency injection via context
async function processPayment(input: PaymentInput, ctx: Context) {
  const [payment] = await ctx.sql`
    SELECT * FROM payments WHERE id = ${input.paymentId}
  `;
  await ctx.serviceSupabase.from('audit_logs').insert({
    action: 'payment_processed',
    payment_id: input.paymentId
  });
}
```

## What's in the Context

**Core resources** (always available):
- `ctx.env` - Environment variables
- `ctx.shutdownSignal` - AbortSignal for graceful shutdown
- `ctx.rawMessage` - pgmq message metadata (msg_id, read_ct, etc.)
- `ctx.stepTask` - Step execution details (flows only)

**Supabase resources**:
- `ctx.sql` - PostgreSQL client (postgres.js)
- `ctx.anonSupabase` - Client with anon key (respects RLS)
- `ctx.serviceSupabase` - Client with service role (bypasses RLS)

## Key Benefits

1. **Zero Configuration** - No connection boilerplate
2. **Managed Resources** - pgflow handles pooling and lifecycle
3. **Type Safety** - Full TypeScript support
4. **Testable** - Mock only what you use:

```typescript ins="{ env: { API_KEY: 'test' } }"
// Handler uses only env? Test with only env:
await handler(input, { env: { API_KEY: 'test' } } as any);
```

## Migration

Existing handlers continue to work. Add the context parameter when you need platform resources:

```typescript ins="ctx" "ctx.sql"
// Old handlers work fine
async function handler(input) { return { ok: true }; }

// New handlers get context
async function handler(input, ctx) {
  const data = await ctx.sql`SELECT * FROM table`;
  return { ok: true, count: data.length };
}
```

## What's Next

Future releases will support custom resources (OpenAI, Stripe, etc.) while maintaining the same clean interface.

**Updated packages**: `@pgflow/edge-worker` and `@pgflow/dsl`
