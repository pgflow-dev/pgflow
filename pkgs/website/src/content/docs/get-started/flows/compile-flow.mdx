---
title: Compile flow to SQL
description: Learn how to compile your flow definition to SQL and apply it to your database
sidebar:
  order: 30
---

import { Aside, Steps } from "@astrojs/starlight/components";

Now that we've defined our flow and registered it, we need to compile it to SQL and apply it to your database.

<Aside type="caution" title="Prerequisites">
Before continuing, make sure you have:
- Completed the [flow definition](/get-started/flows/create-flow/) from the previous step
- **Registered your flow** in `supabase/functions/pgflow/index.ts`
- The Supabase CLI installed and configured
</Aside>

<Steps>

1. ### Start edge functions

   Open a terminal and start the edge functions server:

   ```bash frame="none"
   npx supabase functions serve
   ```

   <Aside type="tip">
   Keep this terminal open - the edge functions server must be running for compilation.
   </Aside>

2. ### Compile the flow

   In a **separate terminal**, run the compile command with the flow slug:

   ```bash frame="none"
   npx pgflow@latest compile greet_user
   ```

   <Aside type="note" title="Slug, not file path">
   Notice we pass the **flow slug** (`greet_user`), not the file path. The slug comes from your flow definition: `new Flow({ slug: 'greet_user' })`.
   </Aside>

   You should see output like this:

   ```
   Successfully compiled flow to SQL
   Migration file created: supabase/migrations/20250505120000_create_greet_user_flow.sql
   ```

3. ### Examine the generated SQL (optional)

   Let's look at what got generated:

   ```bash frame="none"
   cat supabase/migrations/*_create_greet_user_flow.sql
   ```

   The generated SQL looks like this:

   ```sql
   SELECT pgflow.create_flow('greet_user');
   SELECT pgflow.add_step('greet_user', 'full_name');
   SELECT pgflow.add_step('greet_user', 'greeting', ARRAY['full_name']);
   ```

   :::tip[Step Configuration]
   This is a simple example showing basic step registration. Steps can also be configured with retry behavior, timeouts, and delays. See [Step Execution Options](/reference/configuration/step-execution/) for all available configuration options.
   :::

4. ### Apply the migration

   Apply the migration to register the flow in your database:

   ```bash frame="none"
   npx supabase migrations up
   ```

   You should see:

   ```
   Applying migration 20250505120000_create_greet_user_flow.sql...done
   ```

</Steps>

:::note[How compilation works]
The compile command sends an HTTP request to your local `pgflow` edge function, which compiles the TypeScript and returns SQL. This approach uses the same Deno runtime as production, ensuring consistency.

<details>
<summary>Learn more</summary>

When you run `pgflow compile greet_user`:

1. The CLI sends a request to `http://127.0.0.1:54321/functions/v1/pgflow/flows/greet_user`
2. The ControlPlane edge function looks up the flow in its registry
3. It compiles the flow to SQL using `@pgflow/dsl`
4. The CLI receives the SQL and writes it to a migration file

See [Compilation](/concepts/compilation/) for more details.
</details>
:::

## Troubleshooting

### "Could not connect to ControlPlane"

Make sure edge functions are running:

```bash frame="none"
npx supabase functions serve
```

### "Flow not found"

The flow is not registered in `index.ts`. Make sure you:

1. Imported your flow in `supabase/functions/pgflow/index.ts`
2. Added it to the `ControlPlane.serve([...])` array

:::note[Flow definitions are immutable]
Once a flow is registered in the database, its structure cannot be modified. To change a flow, you can either [delete it](/build/delete-flows/) (development only) or use [versioning](/build/version-flows/).

<details>
<summary>Why immutability matters</summary>

<br/>

**What does immutability mean?**

Once a flow is registered, you cannot modify its structure - no adding/removing steps, changing dependencies, or renaming steps.

**Why this protects production:**

- Running workflows continue safely through deployments
- Historical runs remain intact with their original structure
- Flows behave consistently from start to finish
- Complete audit trails are preserved

This ensures your production workflows are stable, predictable, and never break mid-execution.
</details>
:::
