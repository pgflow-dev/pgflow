---
title: Compile flow to SQL
description: Learn how to compile your flow definition to SQL and apply it to your database
sidebar:
  order: 3
---

import { Aside, Steps } from "@astrojs/starlight/components";
import NotProductionReady from '@/components/NotProductionReady.astro';

Now that we've defined our flow, we need to register it in the database. pgflow provides a CLI tool that compiles your TypeScript flow definition into SQL migrations that can be applied to your Supabase database.

<NotProductionReady />

## What is compilation?

The pgflow compilation process:

1. Analyzes your TypeScript flow definition
2. Extracts information about steps, dependencies, and options
3. Generates SQL commands that register the flow and its structure in your database
4. Creates a migration file that can be applied to your database

This is an essential step because pgflow's runtime executes flows based on their database representation, not the TypeScript code directly.

<Aside type="caution" title="Prerequisites">
Before continuing, make sure you have:
- Completed the [flow definition](/getting-started/create-first-flow/) from the previous step
- The Supabase CLI installed and configured
</Aside>

<Steps>
1. ### Compile the flow to SQL

    Run the pgflow compile command, pointing to your flow definition file:

    ```bash frame="none"
    npx pgflow@latest compile supabase/functions/_flows/analyze_website.ts
    ```

    This will:
    - Parse your TypeScript flow definition
    - Extract the flow structure, step dependencies, and configuration
    - Generate SQL commands to register the flow in the database
    - Create a timestamped migration file in your Supabase migrations folder

    You should see output like this:

    ```
    ✓ Successfully compiled flow to SQL
    ✓ Migration file created: supabase/migrations/20250505120000_create_analyze_website_flow.sql
    ```

2. ### Examine the generated SQL

    Let's look at what got generated. Open the migration file in your editor:

    ```bash frame="none"
    cat supabase/migrations/20250505120000_create_analyze_website_flow.sql
    ```

    The migration file contains SQL commands that:
    
    1. Create the flow definition
    2. Add each step with its configuration
    3. Define dependencies between steps

    Here's a simplified view of what the SQL looks like:

    ```sql
    -- Create the flow
    SELECT pgflow.create_flow('analyze_website', max_attempts => 3, base_delay => 1, timeout => 4);

    -- Add steps and define their dependencies
    SELECT pgflow.add_step('analyze_website', 'website');
    SELECT pgflow.add_step('analyze_website', 'summary', ARRAY['website']);
    SELECT pgflow.add_step('analyze_website', 'tags', ARRAY['website']);
    SELECT pgflow.add_step('analyze_website', 'saveToDb', ARRAY['summary', 'tags']);
    ```

    This SQL representation is what the pgflow runtime system uses to execute your workflow.

3. ### Apply the migration

    Now that we have the SQL migration, we need to apply it to our database:

    ```bash frame="none"
    npx supabase migrations up
    ```

    This will execute the SQL migration and register your flow definition in the database.

    If successful, you should see output like:

    ```
    Applying migration 20250505120000_create_analyze_website_flow.sql...done
    ```

</Steps>

## Managing flow changes and versioning

:::caution[Current Compilation Limitations]
**Important:** The current version of pgflow's compiler:

1. Always creates a **new migration file** for any changes
2. Does not provide automatic update functionality for existing flows
3. Cannot safely change step dependencies or flow structure

For any changes to an existing flow, you must:
- Manually handle migration files
- **NEVER** change dependencies, step slugs, or flow structure in existing flows
- For non-breaking changes, manually update using SQL commands
:::

:::danger[Prohibited Changes]
DO NOT attempt to change these aspects of an existing flow:
- Step slugs
- Dependencies between steps
- Adding or removing steps
- Altering the flow's input type structure

These changes will break in-progress runs and cause data compatibility issues.
:::

### Version management strategy

pgflow uses the flow's `slug` as its identifier, so to create a new version:

1. **Create a new flow definition file** with a versioned slug (e.g., `analyze_website_v2.ts`)
2. **Manually manage migration files**:
   - Keep previous migration files for existing runs
   - Create new migrations for the new flow version

```typescript
// analyze_website_v2.ts
export default new Flow<Input>({
  slug: 'analyze_website_v2',  // Note the versioned slug
  // ...configuration
})
```

### Safe vs. breaking changes

| Safe Changes | Breaking Changes |
| ------------ | --------------- |
| Modifying step implementation | Adding/removing steps |
| Adjusting retry parameters | Changing step dependencies |
| Updating timeout values | Modifying input/output types |
| Bug fixes within steps | Changing step slug names |

### Updating non-breaking configuration options

For non-breaking changes like adjusting retry settings or timeouts, you must manually update the database:

```sql
-- Updating flow-level options
UPDATE pgflow.flows 
SET opt_max_attempts = 5, opt_timeout = 10, opt_base_delay = 2
WHERE flow_slug = 'analyze_website';

-- Updating step-level options
UPDATE pgflow.steps
SET opt_max_attempts = 3, opt_timeout = 30
WHERE flow_slug = 'analyze_website' AND step_slug = 'website';
```

Available options that can be safely updated:
- `opt_max_attempts`: Maximum retry attempts
- `opt_base_delay`: Base delay between retries (seconds)
- `opt_timeout`: Maximum execution time (seconds)
- `opt_jitter`: Random jitter for retry timing

### Task reusability

The separation of tasks from flows helps with versioning:

- Tasks can be reused across multiple flow versions
- Implementation details can evolve independently of flow structure
- New flow versions can reuse existing task implementations

```typescript
// Both flow versions can use the same task implementations
// analyze_website_v1.ts and analyze_website_v2.ts
import { scrapeWebsite } from '../_tasks/scrapeWebsite.ts';
```

:::note[Flow Versioning Tips]
- For non-breaking configuration changes: Update database directly with SQL
- For breaking changes: Always create a new flow with a versioned slug
- Consider a versioning scheme (v1, v2, etc.) for your flow slugs
- Always test migrations thoroughly before applying in production
- Plan how to migrate in-progress runs when deploying new versions
:::

<Aside>
Now that your flow is registered in the database, the next step is to [set up a worker and trigger the flow](/getting-started/trigger-and-monitor/).
</Aside>
