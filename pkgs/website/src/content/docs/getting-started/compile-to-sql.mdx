---
title: Compile flow to SQL
description: Learn how to compile your flow definition to SQL and apply it to your database
sidebar:
  order: 3
---

import { Aside, Steps } from "@astrojs/starlight/components";
import NotProductionReady from '@/components/NotProductionReady.astro';

Now that we've defined our flow, we need to register it in the database. pgflow provides a CLI tool that compiles your TypeScript flow definition into SQL migrations that can be applied to your Supabase database.

<NotProductionReady />

## What is compilation?

The pgflow compilation process:

1. Analyzes your TypeScript flow definition
2. Extracts information about steps, dependencies, and options
3. Generates SQL commands that register the flow and its structure in your database
4. Creates a migration file that can be applied to your database

This is an essential step because pgflow's runtime executes flows based on their database representation, not the TypeScript code directly.

<Aside type="caution" title="Prerequisites">
Before continuing, make sure you have:
- Completed the [flow definition](/getting-started/create-first-flow/) from the previous step
- The Supabase CLI installed and configured
</Aside>

<Steps>
1. ### Compile the flow to SQL

    Run the pgflow compile command, pointing to your flow definition file:

    ```bash frame="none"
    npx pgflow@latest compile supabase/functions/_flows/greet_user.ts
    ```

    This will:
    - Parse your TypeScript flow definition
    - Extract the flow structure, step dependencies, and configuration
    - Generate SQL commands to register the flow in the database
    - Create a timestamped migration file in your Supabase migrations folder

    You should see output like this:

    ```
    ✓ Successfully compiled flow to SQL
    ✓ Migration file created: supabase/migrations/20250505120000_create_greet_user_flow.sql
    ```

2. ### Examine the generated SQL

    Let's look at what got generated. Open the migration file in your editor:

    ```bash frame="none"
    cat supabase/migrations/20250505120000_create_greet_user_flow.sql
    ```

    The migration file contains SQL commands that:

    1. Create the flow definition
    2. Add each step with its configuration
    3. Define dependencies between steps

    The generated SQL looks like this:

    ```sql
    SELECT pgflow.create_flow('greet_user');
    SELECT pgflow.add_step('greet_user', 'full_name');
    SELECT pgflow.add_step('greet_user', 'greeting', ARRAY['full_name']);
    ```

    This SQL representation is what the pgflow runtime system uses to execute your workflow.

3. ### Apply the migration

    Now that we have the SQL migration, we need to apply it to our database:

    ```bash frame="none"
    npx supabase migrations up
    ```

    This will execute the SQL migration and register your flow definition in the database.

    If successful, you should see output like:

    ```
    Applying migration 20250505120000_create_greet_user_flow.sql...done
    ```

</Steps>

## Managing flow changes and versioning

:::caution[Current Compilation Limitations]
**Important:** The current version of pgflow's compiler:

1. Always creates a **new migration file** for any changes
2. Does not provide automatic update functionality for existing flows
3. Cannot safely change step dependencies or flow structure

For any changes to an existing flow, you must:
- Manually handle migration files
- **NEVER** change dependencies, step slugs, or flow structure in existing flows
- For non-breaking changes, manually update using SQL commands
:::

:::danger[Prohibited Changes]
DO NOT attempt to change these aspects of an existing flow:
- Step slugs
- Dependencies between steps
- Adding or removing steps
- Altering the flow's input type structure

These changes will break in-progress runs and cause data compatibility issues.
:::

### Version management strategy

pgflow uses the flow's `slug` as its identifier, so to create a new version:

1. **Create a new flow definition file** with a versioned slug (e.g., `greet_user_v2.ts`)
2. **Manually manage migration files**:
   - Keep previous migration files for existing runs
   - Create new migrations for the new flow version

```typescript
// greet_user_v2.ts
export default new Flow<Input>({
  slug: 'greet_user_v2',  // Note the versioned slug
  // ...configuration
})
```

### Safe vs. breaking changes

| Safe Changes | Breaking Changes |
| ------------ | --------------- |
| Modifying step implementation | Adding/removing steps |
| Adjusting retry parameters | Changing step dependencies |
| Updating timeout values | Modifying input/output types |
| Bug fixes within steps | Changing step slug names |

### Updating non-breaking configuration options

For non-breaking changes like adjusting retry settings or timeouts, you must manually update the database with SQL commands.

:::tip[How To Guide]
We've created a detailed guide on [how to update flow options](/how-to/update-flow-options/) that covers:
- All available configuration options
- SQL commands for updating flows and steps
- Best practices for maintaining compatibility

For any non-breaking changes to existing flows, refer to this guide rather than recompiling.
:::

<Aside>
Now that your flow is registered in the database, the next step is to [set up a worker and trigger the flow](/getting-started/trigger-and-monitor/).
</Aside>