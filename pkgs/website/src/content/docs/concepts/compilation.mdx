---
title: Compilation
description: How pgflow compiles TypeScript flows to SQL via HTTP
sidebar:
  order: 25
---

import { Aside } from "@astrojs/starlight/components";

pgflow compiles TypeScript flow definitions to SQL migrations via an HTTP-based architecture. This design eliminates the need for a local Deno installation and ensures compilation uses the same runtime as production.

## How It Works

When you run `pgflow compile greetUser`, the following happens:

```
┌─────────────┐     HTTP GET      ┌─────────────────────┐
│  pgflow CLI │ ─────────────────>│  ControlPlane Edge  │
│             │                   │      Function       │
│             │                   │                     │
│             │     SQL Array     │  1. Look up flow    │
│             │ <─────────────────│  2. Call compileFlow│
│             │                   │  3. Return SQL      │
│             │                   └─────────────────────┘
│  4. Write   │
│  migration  │
└─────────────┘
```

1. **CLI sends request** - The compile command sends an HTTP GET request to:
   `http://127.0.0.1:54321/functions/v1/pgflow/flows/{slug}`

2. **ControlPlane looks up flow** - The edge function has a registry of flows (from your `index.ts`). It finds the flow by slug.

3. **Compilation happens in Deno** - The ControlPlane calls `compileFlow()` from `@pgflow/dsl`, which extracts the flow structure and generates SQL.

4. **SQL returned to CLI** - The response contains an array of SQL statements.

5. **CLI writes migration** - The CLI joins the SQL and writes it to `supabase/migrations/{timestamp}_create_{slug}_flow.sql`.

## The ControlPlane Edge Function

The `pgflow` edge function is created during installation and serves as your project's ControlPlane:

```typescript title="supabase/functions/pgflow/index.ts"
import { ControlPlane } from '@pgflow/edge-worker';
import * as flows from '../../flows/index.ts';

ControlPlane.serve(flows);
```

The ControlPlane:
- **Registers flows** by slug in an in-memory registry
- **Exposes** the `/flows/:slug` endpoint for compilation
- **Returns 404** if a flow slug is not found in the registry
- **Returns 500** with error details if compilation fails

## Why HTTP-Based Compilation?

This architecture provides several benefits:

**No local Deno required** - Users don't need Deno installed on their machine. The Supabase Edge Functions runtime handles everything.

**Same runtime as production** - Flows are compiled using the exact same Deno environment they'll run in, eliminating "works on my machine" issues.

**Consistent dependency resolution** - The `deno.json` import map in your edge function ensures consistent package versions.

**Simpler CLI** - The CLI is a lightweight Node.js package that makes HTTP requests, rather than needing to bundle the entire compilation infrastructure.

## Auto-Compilation

When you start an Edge Worker, pgflow automatically compares your TypeScript flow definition with the database schema and takes action based on the environment.

```d2
...@../../../assets/pgflow-theme.d2

direction: right

start: "Worker\nstarts"
start.class: step_started

exists: "Exists?"
exists.shape: diamond
exists.class: info

compile: "Compile"
compile.class: step_completed

match: "Same\nshape?"
match.shape: diamond
match.class: info

verified: "Verified"
verified.class: step_completed

local: "Local\ndev?"
local.shape: diamond
local.class: warning

recompile: "Delete old\n& compile new"
recompile.class: step_completed

fail: "Fail\nto start"
fail.class: step_failed

polling: "Start\npolling"
polling.class: step_completed

start -> exists: "lookup flow\nin DB by slug"
exists -> compile: "no"
exists -> match: "yes"
match -> verified: "yes"
match -> local: "no"
local -> recompile: "yes"
local -> fail: "prod"
compile -> polling
verified -> polling
recompile -> polling
```

### Local Development

In local development, auto-compilation enables seamless iteration:

1. **No flow exists** → compiles and creates it
2. **Flow exists with same shape** → uses existing schema
3. **Flow exists with different shape** → **deletes the existing flow and all its run data**, then compiles the new version

The workflow is fully automatic:
1. You change your flow code
2. Edge runtime detects the change and restarts the function
3. pgflow cron triggers the function via HTTP request
4. Worker starts, detects shape mismatch, deletes old flow, compiles new one

<Aside type="caution">
**Warning:** In local development, recompiling **deletes the existing flow and all its run data**. This is intentional for fast iteration but means you lose all previous runs.
</Aside>

To disable auto-compilation, set `ensureFlowCompiled: false` in worker options.

### Production

In production, shape mismatches cause the worker to **refuse to start**:
- This prevents accidental data loss from running flows
- Worker fails with `FlowShapeMismatchError`
- Resolution: create a versioned flow (e.g., `processOrderV2`) and deploy a new worker

### What is "Flow Shape"?

**Changes that affect shape (require versioning):**
- Step slugs
- Step order / dependencies
- Step types (single vs map)

**Changes that DON'T affect shape (safe to change):**
- Step options (timeout, retries, maxConcurrency)
- Handler code logic

## Manual Compilation (Optional)

Some teams prefer explicit compilation for:
- SQL migrations in source control
- Code review of flow structure
- CI/CD validation

To compile manually:
```bash frame="none"
npx pgflow compile myFlow
```

This generates a migration file you can review and apply.

## Adding New Flows

To make a flow available for compilation:

1. Create the flow definition in `supabase/flows/`
2. Export it from `supabase/flows/index.ts`

The ControlPlane automatically picks up all flows exported from your `flows/index.ts`.

<Aside type="note">
When running `supabase functions serve`, code changes are detected automatically and the ControlPlane reloads with your new flows.
</Aside>

## Troubleshooting

### "Could not connect to ControlPlane"

Make sure edge functions are running:

```bash frame="none"
npx supabase functions serve --no-verify-jwt
```

### "Flow not found"

Register your flow in `supabase/functions/pgflow/index.ts` and restart the functions server.

## API Reference

For detailed HTTP endpoint documentation, see [ControlPlane API Reference](/reference/control-plane-api/).
