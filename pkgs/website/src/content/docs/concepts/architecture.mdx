---
title: Architecture
description: Understanding pgflow's three-layer architecture and separation of concerns
sidebar:
  order: 25
---

import { Aside, LinkCard, CardGrid } from "@astrojs/starlight/components";

pgflow separates concerns across three distinct layers. Each layer operates at a different conceptual level and solves different classes of problems.

## Overview

<img src="/diagrams/three-layers.svg" alt="Three layers of pgflow architecture" width="90%" />

The diagram shows two key distinctions:

**Build-time** - Write workflows in TypeScript, compile to SQL migrations

**Run-time** - Postgres orchestrates (SQL Core), workers execute your functions (Worker)

## The Three Layers

Each layer has a distinct responsibility:

| Layer | Thinks about | Lives where |
|-------|--------------|-------------|
| **DSL** | "User wants to fanout over array, compile to step definitions" | Your repo |
| **SQL Core** | "This step is ready, spawn N tasks, aggregate results" | Postgres functions |
| **Worker** | "Execute this handler with input, return output or error" | Edge Function (or any runtime) |

The key insight: each layer solves problems at its own abstraction level without understanding the others' concerns.

---

## Layer 3: DSL (User Intent)

**Problem domain:** How do users express workflows naturally?

The TypeScript DSL provides:
- Type-safe method chaining (`.step()`, `.array()`, `.fanout()`)
- Pattern recognition for complex workflows
- Compilation from high-level concepts to DAG primitives
- Full type inference across step dependencies

**What it doesn't think about:** How tasks execute, database state management, or queue mechanics

**Example:**
```typescript
new Flow<Input>({ slug: "process_users" })
  .step({ slug: "fetch_users" }, fetchUsers)
  .array({ slug: "users_array" }, (input) => input.fetch_users)
  .fanout({ slug: "send_email" }, sendEmail)
```

The DSL knows this is a fanout pattern and generates the appropriate step definitions. It doesn't know or care how the SQL Core will spawn tasks or how workers will execute them.

---

## Layer 2: SQL Core (Orchestration)

**Problem domain:** How do workflows execute reliably?

The SQL Core handles:
- Dependency resolution (which steps are ready)
- Step type behaviors (`single` vs `map` execution patterns)
- Task spawning and result aggregation
- Transactional state management
- Completion detection

**What it doesn't think about:** Why steps exist, what DSL syntax created them, or user intent

**Example:**
The SQL Core sees step definitions with clear semantics:
- `step_type='single'` means spawn 1 task
- `step_type='map'` means spawn N tasks from dependency array
- Dependencies met = ready to spawn tasks

It executes these primitives reliably without needing to understand that the DSL created them from a `.fanout()` method.

<Aside type="note" title="State in SQL">
All workflow state lives in Postgres tables. Query `pgflow.step_states` to see exactly where each step is. See [Data Model](/concepts/data-model/) for schema details.
</Aside>

---

## Layer 1: Worker (Task Execution)

**Problem domain:** How do tasks run safely?

The Worker handles:
- Handler function invocation
- Input/output transformation
- Error handling and reporting
- Task-level retry logic

**What it doesn't think about:** Where tasks come from, what depends on them, or workflow context

**Example:**
The worker receives a task with:
```typescript
{
  handler: sendEmail,
  input: { user: { email: "user@example.com" } }
}
```

It executes the handler, returns the result or error. It doesn't know this task is part of a fanout, or that other tasks exist, or what step this belongs to.

<Aside type="tip" title="Swap the Worker">
Any process that can call SQL Core functions works - Edge Functions, Lambda, or your own runtime. The Worker is the only layer you might replace.
</Aside>

---

## The Familiar Pattern

If you've written queue processing code, pgflow's execution model will feel natural:

```typescript
msg = pgmq.read()       // üì• Get work
result = process(msg)   // ‚öôÔ∏è Do work
pgmq.send(next_msg)     // üì§ Queue next
```

üëÜ This is the core loop. pgflow extends this pattern across multi-step workflows - each completed step automatically triggers its dependents.

The SQL Core manages which tasks to enqueue, the Worker executes them, and Postgres tracks all state transitions.

---

## How Layers Interact

Each layer provides reliable primitives for the layer above:

**DSL ‚Üí SQL Core**
- DSL compiles to step definitions with clear semantics
- SQL Core doesn't parse TypeScript or understand user intent
- Contract: step definitions with `step_type`, dependencies, options

**SQL Core ‚Üí Worker**
- SQL Core spawns tasks when dependencies are met
- Worker doesn't track dependencies or workflow state
- Contract: task with handler function, input data, retry config

**Worker ‚Üí SQL Core**
- Worker executes handler, reports success/failure
- SQL Core updates state, checks for newly ready steps
- Contract: task completion with output or error

<Aside type="note" title="No Abstraction Leakage">
Higher layers never need to understand lower layer implementation details. The DSL doesn't know about pgmq queues. The SQL Core doesn't know about TypeScript types. The Worker doesn't know about step dependencies.
</Aside>

---

## Why This Separation Matters

### üß† Cognitive Load Management
Each layer has a bounded problem space. Worker engineers think about reliable task execution. SQL Core engineers think about DAG orchestration algorithms. DSL engineers think about user experience and type systems.

### üîÑ Independent Evolution
- Add new DSL syntax using existing SQL Core primitives
- Optimize SQL Core execution without breaking DSL compilation
- Improve Worker performance without affecting workflow logic

### üß™ Testing and Reasoning
Each abstraction level can be validated in isolation:
- Test SQL Core step behaviors independently of DSL syntax
- Test DSL compilation without running actual workflows
- Validate Worker execution without workflow context

### üîó Composability
Lower layers provide predictable building blocks:
- `step_type='array'` always validates array outputs
- `step_type='map'` always spawns N tasks
- Workers always execute handlers independently

---

## Learn More

<CardGrid>
  <LinkCard
    title="How pgflow Works"
    href="/concepts/how-pgflow-works/"
    description="Practical introduction with state machine and examples"
  />
  <LinkCard
    title="Data Model"
    href="/concepts/data-model/"
    description="SQL schema, tables, and relationships"
  />
</CardGrid>
