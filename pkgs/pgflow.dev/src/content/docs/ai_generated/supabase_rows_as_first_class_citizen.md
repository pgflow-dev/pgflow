---
title: "Supabase Rows as First-Class Citizen"
---

To deepen the integration with Supabase, consider the following ideas:

1. **Typed Step Definitions**: Extend the `StepDefinition` interface to include Supabase-generated types for table rows. This ensures that the input and output of each step are compatible with specific table schemas, reducing runtime errors and improving type safety.

2. **Row-Based Persistence**: Modify the flow to persist step results directly into Supabase tables. Instead of storing results in a generic `step_result` column, map each step's output to a specific table row, using Supabase's type definitions to ensure compatibility.

3. **Supabase Hooks**: Implement hooks that trigger Supabase functions or listen to changes in specific tables. This allows for real-time updates and actions based on database changes, enhancing the flow's responsiveness and interactivity.

4. **Supabase Function Integration**: Allow steps to call Supabase functions directly, using the Supabase client. This can be useful for complex operations that require database-side logic, leveraging Supabase's serverless functions.

5. **Schema-Driven Flow Generation**: Automatically generate flow steps based on Supabase table schemas. This could involve creating default steps for CRUD operations, with the ability to customize logic while maintaining type safety.

6. **Error Handling and Logging**: Integrate Supabase's logging and error handling capabilities to track flow execution and errors. This can provide insights into flow performance and help in debugging issues.

7. **Supabase Auth Integration**: Use Supabase's authentication system to manage access to flows and steps, ensuring that only authorized users can execute or modify certain parts of the flow.

8. **GraphQL Integration**: If using Supabase's GraphQL API, consider integrating it into the flow to allow for more flexible and efficient data querying and manipulation.

By implementing these ideas, you can create a more robust and seamless integration between your flow management system and Supabase, leveraging Supabase's powerful features to enhance your application's capabilities.

```typescript
// Example Supabase table types (generated by Supabase)
interface Database {
  public: {
    Tables: {
      users: {
        Row: {
          id: string;
          name: string;
          email: string;
          credits: number;
        };
        Insert: {
          id?: string;
          name: string;
          email: string;
          credits?: number;
        };
        Update: {
          id?: string;
          name?: string;
          email?: string;
          credits?: number;
        };
      };
      orders: {
        Row: {
          id: string;
          user_id: string;
          amount: number;
          status: "pending" | "completed" | "failed";
        };
        Insert: {
          id?: string;
          user_id: string;
          amount: number;
          status?: "pending" | "completed" | "failed";
        };
        Update: {
          id?: string;
          user_id?: string;
          amount?: number;
          status?: "pending" | "completed" | "failed";
        };
      };
    };
  };
}

// Example flow that processes an order
const OrderProcessingFlow = new Flow<{ orderId: string }>()
  // Fetch order details
  .task("fetchOrder", async (payload) => {
    const order = await supabase
      .from("orders")
      .select("*")
      .eq("id", payload.run.orderId)
      .single();

    return {
      order: order.data as Database["public"]["Tables"]["orders"]["Row"],
    };
  })
  // Fetch user details
  .task("fetchUser", ["fetchOrder"], async (payload) => {
    const user = await supabase
      .from("users")
      .select("*")
      .eq("id", payload.fetchOrder.order.user_id)
      .single();

    return {
      user: user.data as Database["public"]["Tables"]["users"]["Row"],
    };
  })
  // Validate and process order
  .task("processOrder", ["fetchOrder", "fetchUser"], async (payload) => {
    const { order } = payload.fetchOrder;
    const { user } = payload.fetchUser;

    // Check if user has enough credits
    if (user.credits < order.amount) {
      // Update order status to failed
      await supabase
        .from("orders")
        .update({ status: "failed" })
        .eq("id", order.id);

      return {
        success: false,
        error: "Insufficient credits",
      };
    }

    // Process the order
    const newCredits = user.credits - order.amount;

    // Update user credits and order status in a transaction
    const { data, error } = await supabase.rpc("process_order", {
      p_user_id: user.id,
      p_order_id: order.id,
      p_new_credits: newCredits,
    });

    return {
      success: true,
      updatedUser: {
        ...user,
        credits: newCredits,
      } as Database["public"]["Tables"]["users"]["Row"],
      processedOrder: {
        ...order,
        status: "completed",
      } as Database["public"]["Tables"]["orders"]["Row"],
    };
  });

// The type system now knows about all these types:
type OrderProcessingSteps = ReturnType<typeof OrderProcessingFlow.getSteps>;
// fetchOrder step result type: { order: Database['public']['Tables']['orders']['Row'] }
// fetchUser step result type: { user: Database['public']['Tables']['users']['Row'] }
// processOrder step result type: {
//   success: boolean;
//   error?: string;
//   updatedUser?: Database['public']['Tables']['users']['Row'];
//   processedOrder?: Database['public']['Tables']['orders']['Row'];
// }
```
