/**
 * Migration Generator Script for edge-worker
 *
 * Generates TypeScript modules from SQL migration files at build time.
 * This allows static imports of migration content that work across all environments
 * (local dev, JSR, npm, Supabase Edge Functions).
 *
 * The migrations are sourced from the core package and bundled directly into
 * edge-worker, making it fully self-contained without cross-package imports.
 *
 * Usage: tsx scripts/generate-migrations.ts
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

const MIGRATIONS_DIR = '../core/supabase/migrations';
const OUTPUT_DIR = 'src/_generated/migrations';
const GENERATED_DIR = `${OUTPUT_DIR}/_generated`;
const INDEX_FILE = `${OUTPUT_DIR}/index.ts`;
const TYPES_FILE = `${OUTPUT_DIR}/types.ts`;

interface MigrationFile {
  timestamp: string;
  filename: string;
  content: string;
}

function escapeBackticks(str: string): string {
  // Escape backticks and ${} template expressions
  return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${');
}

function getMigrationFiles(): MigrationFile[] {
  const files = fs.readdirSync(MIGRATIONS_DIR);
  const migrations: MigrationFile[] = [];

  for (const filename of files) {
    // Skip non-SQL files and atlas files
    if (!filename.endsWith('.sql') || filename.startsWith('atlas')) {
      continue;
    }

    // Extract 14-digit timestamp from filename (e.g., "20250429164909_...")
    const match = filename.match(/^(\d{14})_/);
    if (!match) {
      console.warn(`Skipping ${filename}: no valid timestamp found`);
      continue;
    }

    const content = fs.readFileSync(path.join(MIGRATIONS_DIR, filename), 'utf-8');
    migrations.push({
      timestamp: match[1],
      filename,
      content,
    });
  }

  // Sort by timestamp (ascending)
  migrations.sort((a, b) => a.timestamp.localeCompare(b.timestamp));

  return migrations;
}

function generateMigrationModule(migration: MigrationFile): string {
  const escapedContent = escapeBackticks(migration.content);
  return `import type { Migration } from '../types.ts';

export const migration: Migration = {
  timestamp: '${migration.timestamp}',
  filename: '${migration.filename}',
  content: \`${escapedContent}\`,
};
`;
}

function generateTypesFile(): string {
  return `/**
 * Migration types for edge-worker
 *
 * Auto-generated by scripts/generate-migrations.ts
 * Do not edit manually.
 */

/**
 * Represents a migration file loaded from @pgflow/core
 */
export interface Migration {
  /** 14-digit timestamp from filename, e.g., "20250429164909" (PK) */
  timestamp: string;
  /** Full filename, e.g., "20250429164909_pgflow_initial.sql" */
  filename: string;
  /** Full SQL content of the migration */
  content: string;
}
`;
}

function generateIndexFile(migrations: MigrationFile[]): string {
  const imports = migrations
    .map((m) => `import { migration as m_${m.timestamp} } from './_generated/m_${m.timestamp}.ts';`)
    .join('\n');

  const arrayItems = migrations.map((m) => `  m_${m.timestamp},`).join('\n');

  return `/**
 * Auto-generated migration exports for edge-worker
 *
 * This file is regenerated by scripts/generate-migrations.ts
 * Do not edit manually.
 */

import type { Migration } from './types.ts';
${imports}

export const migrations: Migration[] = [
${arrayItems}
];

export function getMigrations(): Migration[] {
  return migrations;
}

export type { Migration };
`;
}

function main(): void {
  console.log('Generating migration modules for edge-worker...');

  // Ensure output directories exist
  fs.mkdirSync(GENERATED_DIR, { recursive: true });

  // Clean existing generated migration files
  if (fs.existsSync(GENERATED_DIR)) {
    const existingFiles = fs.readdirSync(GENERATED_DIR);
    for (const file of existingFiles) {
      fs.unlinkSync(path.join(GENERATED_DIR, file));
    }
  }

  // Get and process migrations
  const migrations = getMigrationFiles();
  console.log(`Found ${migrations.length} migrations`);

  // Generate types file
  const typesContent = generateTypesFile();
  fs.writeFileSync(TYPES_FILE, typesContent);
  console.log(`Generated ${TYPES_FILE}`);

  // Generate individual module files
  for (const migration of migrations) {
    const moduleContent = generateMigrationModule(migration);
    const outputPath = path.join(GENERATED_DIR, `m_${migration.timestamp}.ts`);
    fs.writeFileSync(outputPath, moduleContent);
    console.log(`  Generated ${path.basename(outputPath)}`);
  }

  // Generate index file
  const indexContent = generateIndexFile(migrations);
  fs.writeFileSync(INDEX_FILE, indexContent);
  console.log(`Generated ${INDEX_FILE}`);

  console.log('Done!');
}

main();
