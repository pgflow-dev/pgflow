>>> user

i have a documents table (postgres) with JSONB metadata column,
that stores the metadata for structured, hierarchical law documents:

Chapter can contain
	Article can contain
		Paragraph can contain
			Point can contain
				Subpoint cannot contain anything, its the leaf

the metadata only can contain the following fields:
- chapter_no
- article_no
- paragraph_no
- point_no
- subpoint_no
- kind (Chapter, Article, Paragraph, Point, Subpoint)

for given kind only the relevant attributes are stored, so for example
for kind==Chapter, there is only kind and chapter_no in metadata, but for kind==Article,
there is kind, chapter_no and article_no in metadata.

i need to write an sql query to find relevant docs and their parents/children
first step is to filter by custom function "match_lex_docs", this way we build
an initial list of matching documents (of any of the types above)

then i need to use the matching documents' metadata to fetch their parents

then i concatenate the original found list with the parents, and order by: chapter_no, article_no, paragraph_no, point_no, subpoint_no

the resulting list is kinda like a flattened tree ordered by depth first

suggest a good approach to do this

<<< assistant

To achieve this, you will need to use a combination of Common Table Expressions (CTEs) and recursive queries. Here's a step-by-step approach to solving this problem:

1. Use your custom function `match_lex_docs` to find the initial list of matching documents. Store this result in a CTE for further processing.

2. Create a recursive CTE that will traverse the hierarchy upwards to find parent documents. This will involve joining the documents table with itself based on the metadata fields.

3. Concatenate the initial list of documents with their parents.

4. Order the final result set by the hierarchy fields: `chapter_no`, `article_no`, `paragraph_no`, `point_no`, `subpoint_no`.

Here's a rough sketch of what the query might look like:

```sql
WITH RECURSIVE matched_docs AS (
    -- Step 1: Get the initial list of matching documents using your custom function
    SELECT id, metadata
    FROM documents
    WHERE match_lex_docs(metadata)
),
parents AS (
    -- Step 2: Recursively find parents
    SELECT md.id, md.metadata
    FROM matched_docs md
    UNION ALL
    SELECT d.id, d.metadata
    FROM documents d
    INNER JOIN parents p ON
        (d.metadata->>'kind' = 'Chapter' AND d.metadata->>'chapter_no' = p.metadata->>'chapter_no') OR
        (d.metadata->>'kind' = 'Article' AND d.metadata->>'article_no' = p.metadata->>'article_no' AND d.metadata->>'chapter_no' = p.metadata->>'chapter_no') OR
        (d.metadata->>'kind' = 'Paragraph' AND d.metadata->>'paragraph_no' = p.metadata->>'paragraph_no' AND d.metadata->>'article_no' = p.metadata->>'article_no') OR
        (d.metadata->>'kind' = 'Point' AND d.metadata->>'point_no' = p.metadata->>'point_no' AND d.metadata->>'paragraph_no' = p.metadata->>'paragraph_no')
    WHERE d.id <> p.id -- Avoid self-joining
),
final_list AS (
    -- Step 3: Concatenate the original list with the parents
    SELECT * FROM matched_docs
    UNION
    SELECT * FROM parents
)
-- Step 4: Order the final list
SELECT id, metadata
FROM final_list
ORDER BY
    (metadata->>'chapter_no')::int NULLS FIRST,
    (metadata->>'article_no')::int NULLS FIRST,
    (metadata->>'paragraph_no')::int NULLS FIRST,
    (metadata->>'point_no')::int NULLS FIRST,
    (metadata->>'subpoint_no')::int NULLS FIRST;
```

A few things to note:
- The recursive CTE `parents` is using JSONB operators to compare the values in the metadata. Make sure that the comparisons match how your metadata is structured.
- The `ORDER BY` clause is casting the JSONB values to integers for proper sorting; if they are not numeric, adjust the casting accordingly.
- The `NULLS FIRST` option in the `ORDER BY` clause ensures that documents with missing fields (higher in the hierarchy) are sorted before their children.
- The `WHERE d.id <> p.id` condition in the recursive join avoids the document being considered as its own parent.

This is a general approach and would need to be adapted to your specific schema, data, and the way your custom function `match_lex_docs` works. If performance becomes an issue, it may be necessary to optimize the query further, possibly by creating indexes on the JSONB fields used in the joins and order by clause.

>>> user


